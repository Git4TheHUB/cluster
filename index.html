<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="screen-orientation" content="landscape">
  <title>3D Virtual World with Stylized 2D Hand Overlay (Landscape Gyro)</title>
  <style>
    body { 
      margin: 0; 
      background: black; 
      overflow: hidden; 
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    video {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      z-index: 1;
      transition: opacity 0.6s ease;
    }
    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }
    .three-canvas { 
      z-index: 2; 
      opacity: 0; 
      transition: opacity 0.6s ease; 
    }
    .three-canvas.active { 
      opacity: 1; 
    }
    .hand-canvas { 
      z-index: 4; 
    }
    /* Encourage landscape mode */
    @media (orientation: portrait) {
      body::before {
        content: "Please rotate your device to landscape for the best experience";
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.9);
        color: white;
        font-size: 24px;
        font-family: system-ui, sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 20px;
        z-index: 9999;
      }
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js"
    }
  }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="threeCanvas" class="three-canvas"></canvas>
    <canvas id="handCanvas" class="hand-canvas"></canvas>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

    const video = document.getElementById('video');
    const threeCanvas = document.getElementById('threeCanvas');
    const handCanvas = document.getElementById('handCanvas');
    const ctx = handCanvas.getContext('2d');

    let virtualMode = false;
    let renderer;
    let scene, camera;
    let cameraGroup;
    let gyroActive = false;

    function enableGyro() {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(response => {
            if (response === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
              gyroActive = true;
            }
          })
          .catch(console.error);
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
        gyroActive = true;
      }
    }

    // Activate gyro on first touch
    document.body.addEventListener('touchend', enableGyro, { once: true });

    function handleOrientation(event) {
      if (!gyroActive || event.alpha === null) return;

      let yaw   = THREE.MathUtils.degToRad(event.alpha || 0);
      let pitch = THREE.MathUtils.degToRad(event.beta  || 0);
      let roll  = THREE.MathUtils.degToRad(event.gamma || 0);

      // Landscape remapping
      const landscapePitch = -roll;
      const landscapeRoll  = pitch;

      const clampedPitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, landscapePitch));
      const euler = new THREE.Euler(clampedPitch, yaw, landscapeRoll, 'YXZ');
      const quat = new THREE.Quaternion().setFromEuler(euler);

      cameraGroup.quaternion.copy(quat);
    }

    function createSharedVirtualScene() {
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
      hemiLight.position.set(0, 50, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffeecc, 1.4);
      dirLight.position.set(20, 40, 30);
      scene.add(dirLight);

      const groundTex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
      groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
      groundTex.repeat.set(200, 200);

      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(1000, 1000),
        new THREE.MeshStandardMaterial({ map: groundTex, roughness: 0.9 })
      );
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Trees...
      for (let i = 0; i < 30; i++) {
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.7, 6, 8),
          new THREE.MeshBasicMaterial({ color: 0x8B4513 })
        );
        trunk.position.y = 3;

        const foliage = new THREE.Group();
        for (let j = 0; j < 2; j++) {
          const leaf = new THREE.Mesh(
            new THREE.SphereGeometry(2.5 - j * 0.8, 8, 6),
            new THREE.MeshBasicMaterial({ color: 0x228B22 })
          );
          leaf.position.y = 5 + j * 2;
          foliage.add(leaf);
        }

        const tree = new THREE.Group();
        tree.add(trunk, foliage);
        tree.position.x = (Math.random() - 0.5) * 400;
        tree.position.z = (Math.random() - 0.5) * 400;
        scene.add(tree);
      }

      // Clouds...
      const cloudTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud10.png');
      const cloudMaterial = new THREE.SpriteMaterial({ 
        map: cloudTexture, 
        transparent: true, 
        opacity: 0.7, 
        depthWrite: false 
      });

      for (let i = 0; i < 30; i++) {
        const sprite = new THREE.Sprite(cloudMaterial.clone());
        sprite.scale.set(40, 14, 1);
        sprite.position.set(
          (Math.random() - 0.5) * 1000, 
          40 + Math.random() * 30, 
          (Math.random() - 0.5) * 1000
        );
        scene.add(sprite);
      }

      return { scene };
    }

    function setupThree() {
      const { scene: sharedScene } = createSharedVirtualScene();
      scene = sharedScene;

      renderer = new THREE.WebGLRenderer({ 
        canvas: threeCanvas, 
        antialias: false, 
        alpha: true, 
        powerPreference: "high-performance" 
      });

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2));
      renderer.setSize(threeCanvas.clientWidth, threeCanvas.clientHeight);

      camera = new THREE.PerspectiveCamera(
        60, 
        threeCanvas.clientWidth / threeCanvas.clientHeight, 
        0.1, 
        1000
      );

      camera.position.set(0, 1.6, 0);
      cameraGroup = new THREE.Group();
      cameraGroup.add(camera);
      scene.add(cameraGroup);

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();
    }

    function toggleVirtualWorld() {
      virtualMode = !virtualMode;
      if (virtualMode) {
        threeCanvas.classList.add('active');
        video.style.opacity = '0';
      } else {
        threeCanvas.classList.remove('active');
        video.style.opacity = '1';
      }
    }

    // Hand drawing helpers
    const HAND_CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]];
    const PALM_OUTLINE = [[0,5],[5,9],[9,13],[13,17],[17,0]];

    function drawHandOverlay(ctx, landmarks, width, height) {
      ctx.clearRect(0, 0, width, height);
      if (!landmarks) return;

      const points = landmarks.map(lm => ({ x: lm.x * width, y: lm.y * height }));

      // Semi-transparent grey palm fill
      ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (const [i, j] of PALM_OUTLINE) {
        ctx.lineTo(points[j].x, points[j].y);
      }
      ctx.closePath();
      ctx.fill();

      // Thick white skeleton
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      for (const [i, j] of HAND_CONNECTIONS) {
        ctx.beginPath();
        ctx.moveTo(points[i].x, points[i].y);
        ctx.lineTo(points[j].x, points[j].y);
        ctx.stroke();
      }

      // Extra palm outline stroke
      ctx.beginPath();
      for (let k = 0; k < PALM_OUTLINE.length; k++) {
        const [i, j] = PALM_OUTLINE[k];
        if (k === 0) ctx.moveTo(points[i].x, points[i].y);
        ctx.lineTo(points[j].x, points[j].y);
      }
      ctx.stroke();
    }

    let lastPinch = false;
    let pinchCount = 0;
    let pinchTimer = null;

    async function startCamera() {
      const constraints = { 
        video: { 
          facingMode: "environment", 
          width: { ideal: 1280 }, 
          height: { ideal: 720 } 
        } 
      };

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;

        video.onloadedmetadata = () => {
          handCanvas.width = video.videoWidth;
          handCanvas.height = video.videoHeight;

          video.play();
          setupThree();
          setupHandTracking();
        };
      } catch (err) {
        console.error("Camera error:", err);
      }
    }

    async function setupHandTracking() {
      try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
        const handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5
        });

        function predict() {
          if (video.readyState >= video.HAVE_ENOUGH_DATA) {
            const timestamp = performance.now();
            const results = handLandmarker.detectForVideo(video, timestamp);

            let anyPinch = false;
            let currentLandmarks = null;

            if (results.landmarks?.length > 0) {
              const lm = results.landmarks[0];
              currentLandmarks = lm;

              const thumb = lm[4];
              const index = lm[8];
              const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y, thumb.z - index.z);

              if (dist < 0.06) anyPinch = true;
            }

            drawHandOverlay(ctx, currentLandmarks, handCanvas.width, handCanvas.height);

            // Double pinch â†’ toggle virtual world
            if (anyPinch && !lastPinch) {
              pinchCount++;
              if (pinchCount === 1) {
                pinchTimer = setTimeout(() => { pinchCount = 0; }, 700);
              } else if (pinchCount === 2) {
                toggleVirtualWorld();
                pinchCount = 0;
                if (pinchTimer) clearTimeout(pinchTimer);
              }
            }
            lastPinch = anyPinch;
          }
          requestAnimationFrame(predict);
        }

        predict();
      } catch (err) {
        console.error(err);
      }
    }

    startCamera();
  </script>
</body>
</html>

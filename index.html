<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Hand Tracking – Menu Spawns Upright</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    #container { position: relative; width: 100vw; height: 100vh; }
    #video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    #status {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      color: white; background: rgba(0,0,0,0.6); padding: 10px 20px;
      border-radius: 12px; font-family: -apple-system, sans-serif; font-size: 16px; z-index: 10;
    }
    #menu {
      position: absolute; pointer-events: none; opacity: 0; transition: opacity 0.4s ease;
      padding: 25px; background: rgba(255,255,255,0.12); backdrop-filter: blur(15px);
      border-radius: 24px; box-shadow: 0 15px 40px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.25); text-align: center; color: white;
      font-family: -apple-system, sans-serif; font-weight: bold; font-size: 26px;
      z-index: 10; transform-origin: center;
    }
    #menu.visible { opacity: 1; pointer-events: auto; }
    .menu-item {
      margin: 18px 0; padding: 18px; background: rgba(255,255,255,0.18);
      border-radius: 16px; cursor: pointer; transition: background 0.2s;
    }
    .menu-item:active { background: rgba(255,255,255,0.4); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
    <div id="status">Loading model...</div>
    <div id="menu">
      <div>AR Menu</div>
      <div class="menu-item">Action 1</div>
      <div class="menu-item">Action 2</div>
      <div class="menu-item">Action 3</div>
      <div class="menu-item">Close / Pinch Again</div>
    </div>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const menu = document.getElementById('menu');

    const HAND_CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
      [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
      [0,17],[17,18],[18,19],[19,20]
    ];

    function drawSkeleton(landmarks) {
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#00FFAA';
      ctx.strokeStyle = '#00FFAA';
      ctx.lineWidth = 10;
      ctx.lineCap = 'round';
      for (const [i, j] of HAND_CONNECTIONS) {
        const a = landmarks[i];
        const b = landmarks[j];
        ctx.beginPath();
        ctx.moveTo(a.x * canvas.width, a.y * canvas.height);
        ctx.lineTo(b.x * canvas.width, b.y * canvas.height);
        ctx.stroke();
      }

      ctx.shadowBlur = 15;
      ctx.shadowColor = '#FF3366';
      ctx.fillStyle = '#FF3366';
      for (const lm of landmarks) {
        ctx.beginPath();
        ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 16, 0, 2 * Math.PI);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }

    let menuOpen = false;
    let lastPinch = false;

    function updateMenu(landmarks) {
      const thumb = landmarks[4];   // Thumb tip
      const index = landmarks[8];  // Index finger tip

      // Center between the two pinch points
      const centerX = (thumb.x + index.x) / 2;
      const centerY = (thumb.y + index.y) / 2;

      menu.style.left = `${centerX * 100}%`;
      menu.style.top = `${centerY * 100}%`;

      // 3D depth scaling
      const wristZ = landmarks[0].z;
      const depth = -wristZ;
      let scale = 0.6 + depth * 6;
      scale = Math.max(0.5, Math.min(2.5, scale));

      // Force upright orientation – menu always spawns and stays readable
      menu.style.transform = `translate(-50%, -50%) scale(${scale}) rotate(0deg)`;
    }

    async function startCamera() {
      const constraints = {
        video: {
          facingMode: "environment",
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        }
      };

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          video.play();
          setupHandTracking();
        };
      } catch (err) {
        status.textContent = "Camera access denied";
        console.error(err);
      }
    }

    async function setupHandTracking() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        const handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.8,
          minHandPresenceConfidence: 0.8,
          minTrackingConfidence: 0.8
        });

        status.textContent = "Ready! Pinch thumb + index to open menu";

        function predict() {
          if (video.readyState >= video.HAVE_ENOUGH_DATA) {
            const timestamp = performance.now();

            const results = handLandmarker.detectForVideo(video, timestamp);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.landmarks && results.landmarks.length > 0) {
              const landmarks = results.landmarks[0];
              drawSkeleton(landmarks);

              const thumb = landmarks[4];
              const index = landmarks[8];
              const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y, thumb.z - index.z);
              const pinching = dist < 0.06;

              if (pinching && !lastPinch) {
                menuOpen = !menuOpen;
                menu.classList.toggle('visible', menuOpen);
                status.textContent = menuOpen ? "Menu open!" : "Menu closed";
              }
              lastPinch = pinching;

              if (menuOpen) {
                updateMenu(landmarks);
              }

              status.textContent = pinching ? "Pinch detected!" : "Tracking hand";
            } else {
              menu.classList.remove('visible');
              menuOpen = false;
              lastPinch = false;
              status.textContent = "No hand detected – palm toward camera";
            }
          }

          requestAnimationFrame(predict);
        }

        predict();
      } catch (err) {
        status.textContent = "Model failed to load";
        console.error(err);
      }
    }

    startCamera();
  </script>
</body>
</html>
